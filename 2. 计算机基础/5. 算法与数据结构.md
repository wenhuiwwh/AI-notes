# 算法与数据结构(python)

## 1. 引入概念

### 1.1 什么是算法？

举一个例子：如果将最终写好运行的程序比作战场，我们码农便是指挥作战的将军，而我们所写的代码便是士兵和武器。数据结构与算法便是：**兵法**

**<font color='bule'>举例</font>**

先看一道题：如果 **$a+b+c=1000,且a^2+b^2=c^2(a,b,c为自然数)$，**如何求出所有$a、b、c$可能的组合？

### 1.2 第一次尝试

```python
import time
start_time=time.time()
# 注意是三层循环
for a in range(1001):
    for b in range(1001):
        for c in range(1001):
            if a**2+b**2==c**2 and a+b+c==1000:
                print("a = %d, b = %d, c = %d"%(a,b,c))
end_time=time.time()
print("all time: %f"%(end_time-start_time))
```

运行结果：

```shell
a = 0, b = 500, c = 500
a = 200, b = 375, c = 425
a = 375, b = 200, c = 425
a = 500, b = 0, c = 500
all time: 1277.225003
```

**算法的提出**

算法是独立存在的一种解决问题的方法和思想，实现算法的语言并不重要，重要的是思想

**算法的五大特性**

1、输入：算法具有0个或多个输入

2、输出：算法至少有1个或多个输出

3、有穷性：算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成

4、确定性：算法中的每一步都有确定的含义，不会出现二义性

5、可行性：算法的每一步都是可行的，也就是说每一步能够执行有限的次数完成

### 1.3 第二次尝试

```python
import time
start_time=time.time()
# 注意是三层循环
for a in range(1001):
    for b in range(1001):
        c=1000-a-b
        if a**2+b**2==c**2:
            print("a = %d, b = %d, c = %d"%(a,b,c))
end_time=time.time()
print("all time: %f"%(end_time-start_time))
```

运行结果：

```shell
a = 0, b = 500, c = 500
a = 200, b = 375, c = 425
a = 375, b = 200, c = 425
a = 500, b = 0, c = 500
all time: 1.259212
```

### 1.4 算法效率衡量

实现算法程序的执行时间可以反映算法的效率，即算法的优劣，但**单纯的靠运行的时间来比较算法的优劣并不是客观准确的！**我们还要考虑算法的**空间复杂度**，即算法运行时所要占用的内存空间，且程序的运行时间严重依赖于运行环境，因此，如何才能客观评价一个算法的时间效率，即时间复杂度呢？

**时间复杂度与“大O记法”**

**“大O记法”：**<font color='green'>对于单调的整数函数 $f$，如果存在一个整数函数 $g$ 和实常数 $c>0$，使得对于充分大的 $n$ 总有$f(n)<=c*g(n)$，就说函数 $g$ 是 $f$ 的一个渐近函数（忽略常数），记为$f(n)=O(g(n))$。也就是说，在趋向无穷的极限意义下，函数 $f$ 的增长速度受到函数 $g$ 的约束，亦即函数 $f$ 与函数 $g$ 的特征相似。</font>

**时间复杂度：**假设存在函数 $g$，使得算法A处理规模为 $n$ 的问题示例所用时间为 $T(n)=O(g(n))$，则称 $O(g(n))$ 为算法A的渐近时间复杂度，简称时间复杂度，记为 $T(n)$

**时间复杂度的几条基本计算规则**

1、基本操作，即只有常数项，认为其时间复杂度为 $O(1)$

2、顺序结构，时间复杂度按**加法**进行计算

3、循环结构，时间复杂度按**乘法**进行计算

4、分支结构，时间复杂度**取最大值**

判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略，在没有特殊说明时，我们所分析的算法的时间复杂度都是指**最坏时间复杂度**

### 1.5 Python内置类型性能分析

**timeit模块**

该模块可以测试一小段Python代码的执行速度

```python
class timeit.Timer(stmt='pass',setup='pass',timer=<timer function>)
```

Timer：测试小段代码执行速度的类

stmt：要测试的代码语句（statment）;

setup：运行代码时需要的设置

timer：定时器函数，与平台有关

```python
timeit.Timer.timeit(number=1000000)
```

Timer类中测试语句执行速度的对象方法，number参数是测试代码时的测试次数，默认为1000000次，方法返回执行代码的平均耗时，一个float类型的秒数。

**list操作测试**

```python
def test1():
    l=[]
    for i in range(1000):
        l=l+[i]

def test2():
    l=[]
    for i in range(1000):
        l.append(i)

def test3():
    l=[i for i in range(1000)]

def test4():
    l=list(range(1000))


if __name__ == '__main__':
    t1=Timer("test1()","from __main__ import test1")
    print("concat %s seconds"%t1.timeit(1000))
    t2=Timer("test2()","from __main__ import test2")
    print("append %s seconds"%t2.timeit(1000))
    t3=Timer("test3()","from __main__ import test3")
    print("iteration %s seconds"%t3.timeit(1000))
    t4=Timer("test4()","from __main__ import test4")
    print("list range %s seconds"%t4.timeit(1000))
```

运行结果：

```shell
concat 1.7135876835958237 seconds
append 0.07959936294461145 seconds
iteration 0.051591222792426006 seconds
list range 0.01440736152893285 seconds
```

**pop操作**

```python
x=list(range(2000000))
pop_start=Timer("x.pop(0)","from __main__ import x")
print("pop_start %s seconds"%pop_start.timeit(1000))
y=list(range(2000000))
pop_end=Timer("y.pop()","from __main__ import y")
print("pop_end %s seconds"%pop_end.timeit(1000))
```

| list内置操作的时间复杂度 | Big-O Efficiency | dict内置操作的时间复杂度 | Big-O Efficiency |
| ------------------------ | ---------------- | ------------------------ | ---------------- |
| index x[]                | $O(1)$           | copy                     | $O(1)$           |
| index assignment         | $O(1)$           | get item                 | $O(1)$           |
| append                   | $O(1)$           | set item                 | $O(1)$           |
| pop()                    | $O(1)$           | delete                   | $O(1)$           |
| pop(i)                   | $O(1)$           | contains(in)             | $O(1)$           |
| insert(i,item)           | $O(n)$           | iteration                | $O(n)$           |
| del operator             | $O(n)$           |                          |                  |
| iteration                | $O(n)$           |                          |                  |
| contains(in)             | $O(n)$           |                          |                  |
| get slice [x:y]          | $O(k)$           |                          |                  |
| del slice                | $O(n)$           |                          |                  |
| set slice                | $O(n+k)$         |                          |                  |
| reverse                  | $O(n)$           |                          |                  |
| concatenate              | $O(k)$           |                          |                  |
| sort                     | $O(nlogn)$       |                          |                  |
| multiply                 | $O(nk)$          |                          |                  |

### 1.6 算法与数据结构

数据结构指数据对象中数据元素之间的关系，它只是静态的描述了数据元素之间的关系，高效的程序需要在数据结构的基础上设计和选择算法。

**程序=数据结构+算法**

最常用的数据运算有五种：插入、删除、修改、查找、排序



## 2. 顺序表

线性表是记录元素之间一种顺序关系的集合，分为2种实现模型：

**顺序表**，将元素顺序地存放在一块连续的存储区里，元素间的顺序关系由它们的存储顺序自然表示

**链表**，将元素存放在通过链接构造起来的一系列存储块中

### 2.1 顺序表的形式

顺序表的基本存储形式分为2种：

1、数据元素本身连续，每个元素占用的存储单元大小固定相同，元素的下标是其逻辑地址，而元素存储的是物理地址（实际内存地址）可以通过存储区的起始地址$Loc(e_0)$ 加上逻辑地址（第 $i$ 个元素）与存储单元大小（$c$）的乘积计算而得，即：$$Loc(e_i)=Loc(e_0) + c*i$$，因此，访问指定元素无需从头遍历，时间复杂度为 $O(1)$

2、元素大小不统一，则需采用元素外置的方式，将实际元素另行存储，而顺序表中各单元元素保存对应元素的地址信息（即链接）

### 2.2 顺序表的结构与实现

#### 2.2.1 顺序表的结构

一个顺序表的完整形式包括两部分，一部分是表中的元素集合，另一部分是为实现正确操作而需记录的信息，即有关表的整体情况的信息，包括表的**存储容量**和当前**元素个数**两项。

#### 2.2.2 顺序表的基本实现方式

1、**一体式结构**：存储表的元素集合和信息单元以连续的方式安排在一块存储区里，构成整体

2、**分离式结构**：表对象里只保存信息单元（容量和元素个数），实际数据元素存放在一个独立的元素存储区，通过链接与基本表对象关联

#### 2.2.3 元素存储区替换与扩充

1、一体式结构：若想更换数据区，只能整体搬迁，即改变整个顺序表对象

2、分离式结构：只要计算机还有空闲存储，就可以在不改变表对象的前提下对其数据存储区进行扩充，这种技术方式实现的表又叫作动态顺序表

#### 2.2.4 顺序表的操作

**增加和删除元素**

1、尾端加入或删除元素，时间复杂度为 $O(1)$

2、非保序的加入或删除元素（不常见），时间复杂度为 $O(1)$

3、保序的元素加入或删除，时间复杂度为 $O(n)$

### 2.3 python中的顺序表

tuple：采用的是一体式结构实现的顺序表，不支持改变其内部状态的任何操作

list：采用的是一种分离式结构实现的动态顺序表



## 3. 链表

链表可以充分利用计算机内存空间，实现灵活的内存动态管理

**链表的定义**

链表是一种在每一个节点里存放下一个节点位置信息（即地址）的线性表

### 3.1 单项链表

单向链表是一种形式最简单的单链表，它包含一个**信息域**和一个**链表域**，链表域指向下一个节点，最后一个节点的链表域指向空值。

> 注意：单项链表包含一个变量p，它指向单链表的头节点，从p出发能找到表中的任意节点。

#### 3.1.1 节点实现

```python
class Node(object):
    """单链表的节点"""
    def __init__(self,item=None):
        # item存放数据元素
        self.elem=item
        # next是下一个节点的标识
        self.next=None
```

 <img src="http://ww1.sinaimg.cn/large/b2f04ec3ly1gadfss9ichj20sg0lcad7.jpg" alt="单链表操作.jpeg" style="zoom:67%;" />

#### 3.1.2 单链表的操作

- is_empty() 链表是否为空
- length() 链表长度
- travel() 遍历整个链表
- add(item) 链表头部添加元素
- append(item) 链表尾部添加元素
- insert(pos, item) 指定位置添加元素
- remove(item) 删除节点
- search(item) 查找节点是否存在

#### 3.1.3 单链表的实现

```python
class SingleLinkList(object):
    def __init__(self,node=None):
        self._head = node

    def is_empty(self):
        return self._head == None

    def length(self):
        cur = self._head
        count = 0
        while cur != None:
            count += 1
            cur = cur.next
        return count

    def travel(self):
        cur = self._head
        while cur != None:
            print(cur.elem,end=" ")
            cur = cur.next
        print("")
        return None

    def add(self, item):
        node = Node(item)
        node.next = self._head
        self._head = node
        return None

    def append(self, item):
        node = Node(item)
        if self.is_empty():
            self._head = node
        else:
            cur = self._head
            while cur.next != None:
                cur = cur.next
            cur.next = node
        return None

    def insert(self, pos, item):

        if pos <= 0:
            self.add(item)
        elif pos > self.length() - 1:
            self.append(item)
        else:
            pre = self._head
            count = 0
            while count < pos - 1:
                count+=1
                pre = pre.next
            node = Node(item)
            node.next = pre.next
            pre.next = node
        return None

    def remove(self, item):
        cur = self._head
        pre = None
        while cur != None:
            if cur.elem == item:
                if cur == self._head:
                    self._head = cur.next
                else:
                    pre.next = cur.next
                break
            pre = cur
            cur = cur.next
        return None

    def search(self, item):
        cur = self._head
        while cur != None:
            if cur.elem == item:
                return True
            cur = cur.next
        return False



if __name__ == '__main__':
    ll = SingleLinkList()
    print(ll.is_empty())
    print(ll.length())
    ll.append(1)
    ll.append(4)
    ll.append(5)
    print(ll.is_empty())
    print(ll.length())

    # 8 1 2 3 4 5 6
    ll.insert(-1, 9) # 9 8 1 23456
    ll.travel()
    ll.insert(3, 100) # 9 8 1 100 2 3456
    ll.travel()
    ll.insert(10, 200) # 9 8 1 100 23456 200
    ll.travel()
    ll.remove(100)
    ll.travel()
    ll.remove(9)
    ll.travel()
    ll.remove(200)
    ll.travel()
```

### 3.2 双向链表

**实现**

```python
from dataStructure.singleLink import SingleLink

class Node(object):
    def __init__(self, item):
        self.elem = item
        self.prev = None
        self.next = None

        
class DoubleLinkList(SingleLink):


    def add(self, item):
        """链表头部添加元素，头插法"""
        node = Node(item)
        node.next = self._head
        self._head = node
        node.next.prev = node

    def append(self, item):
        """链表尾部添加元素, 尾插法"""
        node = Node(item)
        if self.is_empty():
            self._head = node
        else:
            cur = self._head
            while cur.next != None:
                cur = cur.next
            cur.next = node
            node.prev = cur

    def insert(self, pos, item):
        """指定位置添加元素
        :param  pos 从0开始
        """
        if pos <= 0:
            self.add(item)
        elif pos > (self.length() - 1):
            self.append(item)
        else:
            cur = self._head
            count = 0
            while count < pos:
                count += 1
                cur = cur.next
            # 当循环退出后，cur指向pos位置
            node = Node(item)
            node.next = cur
            node.prev = cur.prev
            cur.prev = node
            node.prev.next = node

    def remove(self, item):
        """删除节点"""
        cur = self._head
        while cur != None:
            if cur.elem == item:
                # 先判断此结点是否是头节点
                # 头节点
                if cur == self._head:
                    # 只有一个节点
                    if cur.next:
                        cur.next.prev = None
                    self._head = cur.next
                else:
                    cur.prev.next = cur.next
                    # 删除的是尾结点
                    if cur.next:
                        cur.next.prev = cur.prev
                break
            else:
                cur = cur.next


if __name__ == '__main__':
    ll = DoubleLinkList()
    print(ll.is_empty())
    print(ll.length())

    ll.append(1)
    print(ll.is_empty())
    print(ll.length())
```

### 3.3 单项循环链表

```python
from dataStructure.singleLinkList import SingleLinkList

class Node(object):
    def __init__(self,item):
        self.elem=item
        self.next=None


class SingleCycleLinkList(SingleLinkList):
    def __init__(self,node=None):
        super().__init__()
        if self._head:
            self._head.next=node

    def is_empty(self):
        """链表是否为空"""
        return self._head==None

    def length(self):
        """链表长度"""
        cur=self._head
        count=1
        if self.is_empty():
            return 0
        while cur.next!=self._head:
            count+=1
            cur=cur.next
        return count

    def travel(self):
        """遍历整个链表"""
        cur=self._head
        if cur==None:
            return None
        while cur.next!=self._head:
            print(cur.elem,end=" ")
            cur=cur.next
        print(cur.elem)
        print("")
        return None

    def append(self,item):
        """链表尾部添加元素，尾插法"""
        node=Node(item)
        # 链表为空
        if self.is_empty():
            self._head=node
            node.next=node
        else:
            cur=self._head
            while cur.next!=self._head:
                cur=cur.next
            cur.next=node
            node.next=self._head
        return None

    def add(self,item):
        """链表头部添加元素，头插法"""
        node=Node(item)
        if self.is_empty():
            self._head=node
            node.next=node
        else:
            node.next=self._head
            cur=self._head
            while cur.next!=self._head:
                cur=cur.next
            cur.next=node
            self._head=node
        return None

    def remove(self,item):
        """删除节点"""
        if self.is_empty():
            return None
        cur=self._head
        pre=None
        while cur.next!=self._head:
            # 若删除的不是尾结点
            if cur.elem==item:
                # 若删除的是头结点
                if cur==self._head:
                    rear=self._head
                    while rear.next!=self._head:
                        rear=rear.next
                    self._head=cur.next
                    rear.next=self._head
                # 若删除的是中间节点
                else:
                    pre.next=cur.next
                return None
            else:
                pre=cur
                cur=cur.next
        # 若删除的是尾结点
        if cur.elem==item:
            if cur==self._head:
                self._head=None
            else:
                pre.next=cur.next
        return None


if __name__ == '__main__':
    ll=SingleCycleLinkList()
    print(ll.is_empty())
    print(ll.length())
    print(ll.travel())
    ll.append(3)
    ll.append(5)
    ll.append(8)
    ll.insert(2,-12)
    print(ll.is_empty())
    print(ll.length())
    ll.travel()
    ll.add(-1)
    print(ll.travel())
    ll.remove(-1)
    print(ll.travel())
```

## 4. 栈

栈，它的特点在于只能允许在容器的一端（称为栈顶端指标，英语：top）进行加入数据（英语：push）和输出数据（英语：pop）的运算，我们用顺序表实现栈

### 4.1 栈的操作

- Stack() 创建一个新的空栈
- push(item) 添加一个新的元素item到栈顶
- pop() 弹出栈顶元素
- peek() 返回栈顶元素
- is_empty() 判断栈是否为空
- size() 返回栈的元素个数

```python
class Stack(object):
    def __init__(self):
        self.__item=[]

    def is_empty(self):
        """判空"""
        return len(self.__item)==0

    def push(self,item):
        """入栈"""
        self.__item.append(item)
        return None

    def pop(self):
        """出栈"""
        if not self.is_empty():
            return self.__item.pop()
        return "栈为空"

    def peek(self):
        """返回栈顶元素"""
        if not self.is_empty():
            return self.__item[-1]
        return "栈为空"

    def size(self):
        """返回栈的元素个数"""
        if not self.is_empty():
            return len(self.__item)
        return "栈为空"

if __name__ == '__main__':
    stack=Stack()
    print(stack.is_empty())
    print(stack.peek())
    print(stack.size())
```

## 5. 队列

### 5.1 普通队列

**操作**

- Queue() 创建一个空的队列
- push(item) 往队列中添加一个item元素
- pop() 从队列头部删除一个元素
- is_empty() 判断一个队列是否为空
- size() 返回队列的大小

**实现**

```python
class Queue(object):
    def __init__(self):
        self.__item=[]

    def is_empty(self):
        """判空"""
        return len(self.__item)==0

    def push(self,item):
        """入队"""
        self.__item.append(item)
        return "入队成功！"

    def pop(self):
        """出队"""
        if not self.is_empty():
            return self.__item.pop(0)
        return "队列为空"


    def size(self):
        """返回队列的元素个数"""
        if not self.is_empty():
            return len(self.__item)
        return "队列为空"

if __name__ == '__main__':
    queue=Queue()
    print(queue.is_empty())
    print(queue.push(1))
    print(queue.push(3))
    print(queue.push(4))
    print(queue.pop())
    print(queue.pop())
    print(queue.size())
```

### 5.2 双端队列

双端队列中的元素可以从两端弹出，其限定插入和删除操作在表的两端进行。双端队列可以在队列任意一端入队和出队

**操作**

* Deque() 创建一个空的双端队列
* add_front(item) 从队头加入一个item元素
* add_rear(item) 从队尾加入一个item元素
* remove_front() 从队头删除一个item元素
* remove_rear() 从队尾删除一个item元素
* is_empty() 判断双端队列是否为空
* size() 返回队列的大小

**实现**

```python
class Deque(object):
    def __init__(self):
        self.item=[]

    def add_front(self,item):
        """从队头加入一个item元素"""
        return self.item.insert(0,item)

    def add_rear(self,item):
        """从队尾加入一个item元素"""
        return self.item.append(item)

    def remove_front(self):
        """从队头删除一个item元素"""
        if not self.is_empty():
            return self.item.pop(0)
        return "队列为空"

    def remove_rear(self):
        """从队尾删除一个item元素"""
        if not self.is_empty():
            return self.item.pop()
        return "队列为空"

    def is_empty(self):
        """判断双端队列是否为空"""
        return len(self.item)==0

    def size(self):
        """返回队列的大小"""
        if not self.is_empty():
            return len(self.item)
        return "对列为空"


if __name__ == '__main__':
    deque=Deque()
    deque.add_front(1)
    deque.add_front(2)
    deque.add_rear(4)
    deque.add_rear(8)
    print(deque.size())
    print(deque.remove_front())
    print(deque.remove_rear())
    print(deque.remove_rear())
    print(deque.remove_rear())
    print(deque.remove_rear())
    print(deque.size())
```

## 6. 散列表(哈希表)

### 6.1 概念

散列表：是一种数据的集合，其中的每个数据都是通过某种特定的方式进行存储以方便日后的查找

槽：散列表的每个位置叫做槽，能够存放一个数据项，并且从0开始递增的整数命名

散列函数：某个数据项与在散列表中存储它的槽之间的映射叫做散列函数，最简单的散列函数就是求余法（除留余数法）。

负载因子：一般地，我们把槽被占据的比例叫做负载因子，公式：$\lambda=\frac{数据项个数}{散列表的大小}$

搜索：现在当我们想要查找一个数据项时，我们只需要使用散列函数去计算得到这个数据项对应的槽的名字并在这个槽中检查该数据项是否存在，这个搜索过程的时间复杂度为$O(n)$。

<font color='red'>**问题**</font>：它仅能在每个数据项在散列表中占有不同的槽的情况下才能正常运作，若两个甚至多个数据需要存储在同一个槽中，这种情况就被称为**冲突**。

### 6.2 散列函数

完美散列函数：对于一组给定的数据项，如果一个散列函数可以将每一个数据项都映射到不同的槽中，那么这样的散列函数叫做完美散列函数。

目标：创建一个能够将冲突的数量降到最小，计算方便，并且最终将数据项分配到散列表中的散列函数，这里有几种方法可以去扩展求余方法。

**1.折叠法**

基本步骤就是：首先将数据分成相同的长度的片段（最后一个片段长度可能不等），接着将这些片段相加，再求余得到其散列值

例：我们有一串电话号码436-555-4601，我们可以两个一组将这个号码分成5段$(43,65,55,46,01)$，假设散列表有11个槽，我们就需要将和进行求余，求余得到$219\%11=10$

```python
def hash(aStr,tableSize):
    """用ASCII数值散列一个字符串"""
    sum=0
    for value in aStr:
        sum+=ord(value)
    return sum%tableSize


if __name__ == '__main__':
    print(hash("cat",11))
```

**2. 平方取中法**

我们首先将数据项做平方运算，然后取平方数的中间两位，再对散列表的大小求余，例如：对44进行散列，首先$44*44=1936$，然后取中间的93，对散列表大小11求余，$93\%11=5$

**注意**：散列函数必须足够高效以防止它成为占据存储空间和搜索进程的主要部分，如果散列函数过于复杂，导致花费大量的时间去计算槽的名称，可能还不如进行简单的顺序搜索或者二分法搜索，失去了散列的意义。

### 6.3 冲突解决方法

我们现在回到冲突问题，当两个数据散列到相同的槽，我们必须用一种系统化的方法将第二个数据放到散列表里，这个过程叫做冲突解决。

#### 6.3.1 开放定址法

从发生冲突的位置开始顺序向下开始寻找，直到我们遇到第一个空的槽。注意到我们可能需要回到第一个槽（循环）来实现覆盖整个散列表。  <font color='red'>开放定址法需要的表长度要大于等于所需要存放的元素。</font>

**1. 线性探测**

通过系统地向后搜索每一个槽，我们将这种实现开放地址的技术叫做线性探测。  

<font color='red'>**缺点**</font>：会产生集中的趋势，数据会在表中聚集。这意味着如果对于同一散列值产生了许多冲突时，周边的一系列槽都将会被线性探测填充。这将会对正在被填入的新数据产生影响。

**2. 再散列探测**

我们不再按顺序一个一个地寻找新槽，而是跳过一些槽，这样能更加平均地分配出现冲突的数据，进而潜在地减少集中问题出现的次数，函数形式为：

```python
# 开放地址法形式
newhashvalue=rehash(oldhashvalue)
# 简单的线性探测形式
rehash(pos)=(pos+1)%sizeoftable
# “+3”的再散列探测形式
rehash(pos)=(pos+3)%sizeoftable
# 归纳起来的形式
rehash(pos)=(pos+skip)%sizeoftable
```

<font color='red'>注意</font>：选择跳过的槽的个数必须保证所有槽最终都能被遍历。否则，有些槽将会被闲置。为了保证这一点，我们通常建议将槽的数目设置成质数，比如11。

**3. 二次探测**

我们不是每次在冲突时选择跳过固定个数的槽，而是使用一个再散列函数使每次跳过的槽的数量依次增加1,3,5,7,9，以此类推。这意味着如果原槽在第h个发生冲突，那么再散列时访问的槽为第h+1,h+4,h+9,h+16个，换言之，二次探测法使用一个连续的完全平方数数列作为它的跳跃值。

#### 6.3.2 链地址法

除了寻找空槽的开放定址技术外，另一种方案就是将容纳单个数据项的槽扩展为容纳数据项集合(或者对数据项链表的引用)

这样，散列表中的每个槽就可以容纳多个数据项，如果有散列冲突发生，只需要简单地将数据项添加到数据项集合中。

查找数据项时则需要查找同一个槽中的整个集合，当然，随着散列冲突的增加，对数据项的查找时间也会相应增加。

### 6.4 ADT Map

**概念**

Python最有用的内置数据类型之一是“字典”，它是一种可以保存key-data键值对的数据类型，其中关键码key可用于查询关联的数据值data，这种键值关联的方法通常称为“映射map”

**操作**

`Map()`：创建一个空映射，返回空映射对象；

`put(key,value)`：将key-value关联加入映射中，如果key已经存在，则将value替换原来的旧关联值；

`get(key)`：给定key，返回关联的数据值，如不存在，则返回None；

`del`：通过`del map[key]` 的语句形式删除key-val关联；

`len()`：返回映射中key-value关联的数目；

in：通过`key in map` 的语句形式，返回key是否存在于关联中，布尔值

备注：字典的一个巨大的好处在于给定密钥时，我们能够迅速的找到与其关联的数据值。为了使得这种快速搜索得以实现，我们需要一种高效的搜索方法。我们可以使用一个顺序列表或者使用二分法搜索，但是更好地方法是使用散列表的方式。正如之前所描述的，在一个散列表中搜索数据的时间复杂度在 $O(1)$ 级别。  

**实现**

我们运用两个列表来创造一个散列表类 ` HashTable class` 来实现映射的数据结构类型。其中一个称`slots`（槽），用来存储密钥，另一个平行列表称作data，用来存储数据值。当我们查找一个密钥时，对应的data列表中的位置保存着对应的数据值。依照之前的想法，我们把密钥表当作一个散列表来处理。注意到散列表的初始大小为11。  

```python
class HashTable:
    def __init__(self):
        self.size = 11
        self.slots = [None] * self.size
        self.data = [None] * self.size

    def hashFunc(self, key):
        """哈希函数为求余法"""
        return key % self.size

    def reHash(self, oldKey):
        """冲突解决技术："+1"的线性探测"""
        return (oldKey + 1) % self.size

    def put(self, key, value):
        hashValue = self.hashFunc(key)
        if self.slots[hashValue] is None:
            self.slots[hashValue] = key
            self.data[hashValue] = value
        else:
            if self.slots[hashValue] == key:
                # 若key存在，则更新value
                self.data[hashValue] = value
            else:
                # 若产生冲突，则进行线性探测
                nextSlot = self.reHash(hashValue)
                while self.slots[nextSlot] is not None and self.slots[nextSlot] != key:
                    nextSlot = self.reHash(nextSlot)
                if self.slots[nextSlot] is None:
                    self.slots[nextSlot] = key
                    self.data[nextSlot] = value
                else:
                    self.data[nextSlot] = value
```

上述代码中，假设最终一定能找到一个能让新的密钥填入的槽，除非它已经在 `self.slots` 中存在。基于这样的假设，它能够计算出最初的散列值，如果发现对应的槽不为空时，调用再散列（ rehash）函数直到找到空槽位置。如果一个非空的槽已经含有该密钥，那么就将其数据值替换为当前数据值。  

```python
    def get(self, key):
        # 标记散列值为查找起点
        startSlot = self.hashFunc(key)
        data = None
        stop = False
        found = False
        pos = startSlot
        # 找key，直到空槽或回到起点
        while self.slots[pos] is not None and not found and not stop:
            if self.slots[pos] == key:
                found = True
                data = self.data[pos]
            else:
                pos = self.reHash(pos)
                if pos == startSlot:
                    stop = True
        return data

    def __getitem__(self, key):
        return self.get(key)


if __name__ == '__main__':
    # print(hash("cat",11))
    h = HashTable()
    h[54] = "cat"
    h[26] = "dog"
    print(h.slots)
    print(h.get(54))
```

相似的， get函数也是首先计算最初的散列值。如果结果不在对应的槽中，再散列`reHash`函数就会被用来确定一下个可能存储该密钥的位置。注意到第15行代码确保了我们没有再次回到原槽，保证了搜索操作不会陷入死循环。如果这种情况发生了，那么我们已经遍历所有可能的槽，这个密钥一定是不存在的。  

散列表类 `HashTable class` 的最后一些操作提供了额外的字典类功能。我们重载了运算符 `__getitem__` 和`__setitem__ ` 允许使用“ []”对字典进行访问。这表示一旦一个散列表被建立，我们所熟悉的索引操作符都将是可用的  

## 7. 树与树算法

**树的概念**

树（英语：tree）是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n>=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：

- 每个节点有零个或多个子节点；
- 没有父节点的节点称为根节点；
- 每一个非根节点有且只有一个父节点；
- 除了根节点外，每个子节点可以分为多个不相交的子树；

![lcBxjU.png](https://s2.ax1x.com/2020/01/07/lcBxjU.png)

**术语**

* **节点的度**：一个节点含有的子树的个数称为该节点的度；
* **树的度**：一棵树中，最大的节点的度称为树的度；
* **叶节点**：度为0的节点；
* **父节点**：若一个节点含有子节点，则这个节点称为其子节点的父节点
* **子节点**：一个节点含有的子树的树节点称为该节点的子节点；
* **兄弟节点**：具有相同父节点的节点互称为兄弟节点；
* **节点的层次**：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；
* 树的**高度**或**深度**：树中节点的最大层次；
* **子孙**：以某节点为根的子树中任一节点都称为该节点的子孙；
* **森林**：由$m(m>=0)$棵互不相交的树的集合称为森林

**树的种类**

* 无序树：树中任一节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；
* 有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；
  * 二叉树：每个节点最多含有两个子树的树称为二叉树；
    * 完全二叉树：对于一颗二叉树，假设其深度为$d(d>1)$。除了第$d$层外，其它各层的节点数目均已达最大值，且第$d$层所有节点从左向右连续地紧密排列，这样的二叉树称为完全二叉树，其中满二叉树的定义是所有叶节点都在最底层的完全二叉树；
    * 平衡二叉树(AVL树)：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；
    * 排序二叉树(二叉查找树(英语：Binary Search Tree)，也称二叉搜索树、有序二叉树)；
  * 霍夫曼树(用于信息编码)：带权路径最短的二叉树称为哈夫曼树或最优二叉树；
  * B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树

**树的存储和表示**

**顺序存储**：将数据结构存储在固定的数组中，然在遍历速度上有一定的优势，但因所占空间比较大，是非主流二叉树。二叉树通常以链式存储。

 ![lcgHMt.png](https://s2.ax1x.com/2020/01/07/lcgHMt.png)

**链式存储：**

![lc2mW9.png](https://s2.ax1x.com/2020/01/07/lc2mW9.png)

### 7.1 二叉树

#### 7.1.1 基本概念

二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）

#### 7.1.2 性质

1. 在二叉树的第$i$层上至多有$2^{i-1}$个结点$(i>0)$
2. 深度为$k$的二叉树至多有$2^{k}-1$个节点$(k>0)$
3. 对于任意一棵二叉树，如果其叶节点为$N_0$，而度为2的节点总数为$N_2$，则$N_0=N_2+1$;
4. 具有n个节点的完全二叉树的深度必为$\lfloor \log_2n\rfloor+1$
5. 对完全二叉树，若从上至下，从左至右编号，则编号为$i$的节点，其左孩子编号必为$2i$，其右孩子编号必为$2i+1$，其双亲的编号必为$i/2$($i=1$时为根，除外)

**完全二叉树示意图**

 ![lchF1J.png](https://s2.ax1x.com/2020/01/07/lchF1J.png)

**满二叉树示意图**

 ![lchyBq.png](https://s2.ax1x.com/2020/01/07/lchyBq.png)

### 7.2 创建节点及树

#### 7.2.1 节点的创建

通过使用Node类中定义三个属性，分别为elem本身的值，还有lchild左孩子和rchild右孩子

```python
class Node(object):
    """节点类"""
    def __init__(self,item=None,lchild=None,rchild=None):
        self.item=item
        self.lchild=lchild
        self.rchild=rchild
```

#### 7.2.2. 树的创建

树的创建,创建一个树的类，并给一个root根节点，一开始为空，随后添加节点

```python
class Tree(object):
    """树类"""
    def __init__(self):
        self.root=None

    def add(self,item):
        """为树添加节点"""
        node=Node(item)
        # 如果树是空的，则对根节点赋值
        if self.root is None:
            self.root=node
            return
        queue=[self.root]
        # 对已有的节点进行层次遍历
        while queue:
            # 弹出队列的第一个元素
            cur=queue.pop(0)
            if cur.lchild is None:
                cur.lchild=node
                return
            elif cur.rchild is None:
                cur.rchild=node
                return
            else:
                # 如果左右子树都不为空，加入队列继续判断
                queue.append(cur.lchild)
                queue.append(cur.rchild)
```

### 7.3 二叉树的遍历

树的两种重要的遍历模式是深度优先遍历和广度优先遍历,**深度优先一般用递归，广度优先一般用队列。一般情况下能用递归实现的算法大部分也能用堆栈来实现。**

#### 7.3.1 广度优先遍历

从树的root开始，从上到下从左到右遍历整个树的节点

```python
def breathTravel(self):
    """广度优先遍历"""
    if self.root is None:
        return
    queue=[self.root]
    while queue:
        cur=queue.pop(0)
        print(cur.item,end=" ")
        if cur.lchild is not None:
            queue.append(cur.lchild)
            if cur.rchild is not None:
                queue.append(cur.rchild)
```

#### 7.3.2 深度优先遍历

二叉树的深度优先遍历即是沿着树干遍历树的节点，尽可能深的搜索树的分支节点，深度遍历分为先序遍历、中序遍历和后续遍历三种。

**1. 先序遍历**

先访问根节点，然后递归使用先序遍历访问左子树，再递归使用先序遍历访问右子树，顺序：根节点 -> 左子树 -> 右子树

```python
def preTravel(self,node):
    """先序遍历"""
    if node is None:
        return
    print(node.item,end=" ")
    self.preTravel(node.lchild)
    self.preTravel(node.rchild)
```

**2. 中序遍历**

先递归使用中序遍历访问左子树，然后访问根节点，最后再递归使用中序遍历访问右子树，顺序：左子树 -> 根节点 -> 右子树

```python
def inTravel(self,node):
"""中序遍历"""
if node is None:
return
self.inTravel(node.lchild)
print(node.item,end=" ")
self.inTravel(node.rchild)

```

**3. 后序遍历**

先递归使用后续遍历访问左子树，再递归使用后续遍历访问右子树，最后访问根节点，顺序：左子树 -> 右子树 -> 根节点

```python
def postTravel(self,node):
    """后续遍历"""
    if node is None:
        return
    self.postTravel(node.lchild)
    self.postTravel(node.rchild)
    print(node.item,end=" ")
```

**示例**

按照下图的结构写出三种遍历的顺序：

![l5MHwn.png](https://s2.ax1x.com/2020/01/11/l5MHwn.png)

**练习**

![l5Q4tx.png](https://s2.ax1x.com/2020/01/11/l5Q4tx.png)

答案：

先序：a -> b -> c -> d -> e -> f -> g -> h
中序：b -> d -> c -> e -> a -> f -> h -> g
后序：d -> e -> c -> b -> h -> g -> f -> a

**思考**：哪两种遍历方式能够唯一的确定一棵树？
答案：先序遍历加中序遍历，中序遍历加后序遍历，因为中序遍历是划分左右子树的，必须要确定下来

## 8. 排序算法

### 8.1 冒泡排序

冒泡排序算法的运作如下：

- 比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。
- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
- 针对所有的元素重复以上的步骤，除了最后一个。
- 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

 ![bubble.gif](http://ww1.sinaimg.cn/large/b2f04ec3ly1gaf2cxu1eng20ao0aa0tw.gif)

**普通的冒泡排序**

```python
def bubbleSort(li):
    """普通的冒泡排序"""
    # 外层循环是总共走几次
    for j in range(len(li)-1):
        # 内层循环是每次从头走到尾
        for i in range(len(li)-1-j):
            if li[i]>li[i+1]:
                li[i],li[i+1]=li[i+1],li[i]
    return None
```

**改进后的冒泡排序**

如果某次的排序过程中，没有发生任何元素的交换，是否可以停止退出呢？

```python
def improveBubbleSort(li):
    """改进后的冒泡排序"""
    for j in range(len(li)-1):
        # 设定一个标识符
        judge=True
        for i in range(len(li)-1-j):
            if li[i]>li[i+1]:
                # 如果某次交换过程发生交换，就置为False
                judge=False
                li[i],li[i+1]=li[i+1],li[i]
        # 如果没有发生交换，说明已排好序
        if judge:
            return None
    return None

if __name__ == '__main__':
    li=[2,5,1,8,21,3,-2]
    print("未进行冒泡排序之前的列表: ",li)
    bubbleSort(li)
    print("已进行冒泡排序之后的列表: ",li)
    print("优化后的冒泡排序算法的列表: ",li)
```

**时间复杂度**

- 最优时间复杂度：$O(n) $（表示遍历一次发现没有任何可以交换的元素，排序结束。）
- 最坏时间复杂度：$O(n^2)$
- 稳定性：稳定

### 8.2 选择排序

**步骤**

选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小(大) 元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。

![](http://ww1.sinaimg.cn/large/b2f04ec3ly1gaf4e94qaog202s0ab755.gif)

**实现**

```python
def selectionSort(li):
    """选择排序"""
    # 外层循环是总共走几次
    for j in range(len(li)-1):
        # 内层循环是每次比较全部元素
        for i in range(1+j,len(li)):
            if li[j]>li[i]:
                li[j],li[i]=li[i],li[j]

if __name__ == '__main__':
    li=[2,5,1,8,21,3,-2]
    print("未进行选择排序之前的列表: ",li)
    selectionSort(li)
    print("已进行选择排序之后的列表: ",li)
```

**时间复杂度**

- 最优时间复杂度：$O(n^2)$
- 最坏时间复杂度：$O(n^2)$
- 稳定性：不稳定（考虑升序每次选择最大的情况）

### 8.3 插入排序

**步骤**

它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

![](http://ww1.sinaimg.cn/large/b2f04ec3ly1gah699r6jqg208c050q55.gif)

**实现**

```python 
def insertSort(li):
    # i 代表外层循环起始值
    for i in range(1,len(li)):
        # j 代表内层循环起始值
        j=i
        # 执行从右边的无序序列中取出第一个元素，即i位置的元素，然后将其插入到前面的正确位置
        while j>0:
            if li[j]<li[j-1]:
                li[j],li[j-1]=li[j-1],li[j]
                j -= 1
            else:
                break
    return li


if __name__ == '__main__':
    li=[2,5,1,8,21,3,-2]
    print("未进行选择排序之前的列表: ",li)
    insertSort(li)
    print("已进行选择排序之后的列表: ",li)
```

**时间复杂度**

- 最优时间复杂度：$O(n) $（升序排列，序列已经处于升序状态）
- 最坏时间复杂度：$O(n^2)$
- 稳定性：稳定

### 8.4 希尔排序

**思想**

希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。

**步骤**

将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。

![ldbgu6.png](https://s2.ax1x.com/2020/01/04/ldbgu6.png)

**实现**

```python 
def shellSort(li):
    gap=len(li)//2
    # gap变化到0之前，插入算法执行的次数
    while gap>0:
        # 插入算法，与普通的插入算法的区别就是gap步长
        for j in range(gap,len(li)):
            i=j
            # j=[gap,gap+1,gap+2,gap+3,...,n-1]
            while i>0:
                if li[i]<li[i-gap]:
                    li[i],li[i-gap]=li[i-gap],li[i]
                    i -= gap
                else:
                    break
        # 缩短gap步长
        gap//=2
    return None


if __name__ == '__main__':
    li = [2, 5, 1, 8, 21, 3, -2]
    print("未进行选择排序之前的列表: ", li)
    shellSort(li)
    print("已进行选择排序之后的列表: ", li)
```

**时间复杂度**

- 最优时间复杂度：根据步长序列的不同而不同
- 最坏时间复杂度：$O(n^2)$，即是gap=1，降为插入排序的最坏时间复杂度
- 稳定想：不稳定

### 8.5 快速排序

**步骤**

1. 从数列中挑出一个元素，称为"基准"（pivot），
2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。

![lwLbIU.jpg](https://s2.ax1x.com/2020/01/04/lwLbIU.jpg)

**实现**

```python
def quickSort(li,start,end):
    """自实现版本"""
    if start>=end:
        return
    low=start
    high=end
    mid=li[start]
    while low<high:
        while low<high:
            if li[high]<=mid:
                li[low]=li[high]
                low+=1
                break
            else:
                high-=1
        while low<high:
            if li[low]>mid:
                li[high]=li[low]
                high-=1
                break
            else:
                low+=1
        li[low]=mid
    quickSort(li,start,low-1)
    quickSort(li,low+1,end)


def improveQuickSort(alist, start, end):
    """老师版本"""
    # 递归的退出条件
    if start >= end:
        return
    # 设定起始元素为要寻找位置的基准元素
    mid = alist[start]
    # low为序列左边的由左向右移动的游标
    low = start
    # high为序列右边的由右向左移动的游标
    high = end
    while low < high:
        # 如果low与high未重合，high指向的元素不比基准元素小，则high向左移动
        while low < high and alist[high] >= mid:
            high -= 1
        # 将high指向的元素放到low的位置上
        alist[low] = alist[high]
        # 如果low与high未重合，low指向的元素比基准元素小，则low向右移动
        while low < high and alist[low] < mid:
            low += 1
        # 将low指向的元素放到high的位置上
        alist[high] = alist[low]
    # 退出循环后，low与high重合，此时所指位置为基准元素的正确位置
    # 将基准元素放到该位置
    alist[low] = mid
    # 对基准元素左边的子序列进行快速排序
    improveQuickSort(alist, start, low-1)
    # 对基准元素右边的子序列进行快速排序
    improveQuickSort(alist, low+1, end)


if __name__ == '__main__':
    li=[54,26,93,17,77,31,44,55,20]
    print("未进行选择排序之前的列表: ",li)
    # quickSort(li,0,len(li)-1)
    improveQuickSort(li,0,len(li)-1)
    print("已进行选择排序之后的列表: ",li)
```

**时间复杂度**

- 最优时间复杂度：O(nlogn)
- 最坏时间复杂度：O(n2)
- 稳定性：不稳定

> 在最好的情况，每次我们运行一次分区，我们会把一个数列分为两个几近相等的片段。这个意思就是每次递归调用处理一半大小的数列。因此，在到达大小为一的数列前，我们只要作log n次嵌套的调用。

### 8.6 归并排序

**步骤**

归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。

将数组分解最小之后，然后合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。

![l0JktI.gif](https://s2.ax1x.com/2020/01/04/l0JktI.gif)

**实现**

```python
def mergeSort(li):
    mid=len(li)//2
    if mid <1:
        return li
    # left 采用归并排序后形成的有序的新的列表
    left=mergeSort(li[:mid])
    # right 采用归并排序后形成的有序的新的列表
    right=mergeSort(li[mid:])
    # 将两个有序的子序列合并为一个新的整体
    # merge(left, right)
    left_start,right_start=0,0
    result=[]
    while left_start<len(left) and right_start<len(right):
        if left[left_start]<=right[right_start]:
            result.append(left[left_start])
            left_start+=1
        else:
            result.append(right[right_start])
            right_start+=1
    result+=left[left_start:]
    result+=right[right_start:]
    return result

if __name__ == '__main__':
    li=[54,26,93,17,77,31,44,55,20]
    print("未进行选择排序之前的列表: ",li)
    result=mergeSort(li)
    print("已进行选择排序之后的列表: ",result)
```

**时间复杂度**

- 最优时间复杂度：$O(nlogn)$
- 最坏时间复杂度：$O(nlogn)$
- 稳定性：稳定

### 8.7 堆排序

### 8.8 基数排序

### 8.9 桶排序

### 8.10 计数排序

## 9. 搜索算法

搜索是在一个项目集合中找到一个特定项目的算法过程。搜索通常的答案是真的或假的，因为该项目是否存在。 搜索的几种常见方法：顺序查找、二分法查找、二叉树查找、哈希查找

### 9.1 二分查找

**思想**

二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为有序表，且插入删除困难。因此，折半查找方法适用于不经常变动而查找频繁的有序列表。首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。

![lcU39O.png](https://s2.ax1x.com/2020/01/07/lcU39O.png)

**实现**

```python
def binarySearch(li,item):
    """递归法"""
    mid=len(li)//2
    if mid>0:
        if li[mid]==item:
            return True
        elif li[mid]>item:
            return binarySearch(li[:mid],item)
        else:
            return binarySearch(li[mid+1:],item)
    else:
        return False

def binarySearch(li,item):
    """非递归法"""
    start=0
    end=len(li)
    mid=len(li)//2
    while start<end:
        if li[mid]==item:
            return True
        elif li[mid]>item:
            end=mid
        else:
            start=mid+1
        mid=(start+end)//2
    return False



if __name__ == '__main__':
    testlist = [0, 1, 2, 8, 13, 17, 19, 32, 42]
    print(binarySearch(testlist,8))
    print(binarySearch(testlist,-10))
```

## 10. 图与图算法

### 10.1 概念

假如我人在双子峰，现需要前往金门大桥，我打开地图发现有以下线路可以到达目的地，该路线及地点所组成的称为图。

 <img src="http://ww1.sinaimg.cn/large/b2f04ec3ly1gav9xnydiej20ib082761.jpg" alt="graph_road.png" style="zoom:80%;" />

**图（Graph）**：是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：$G(V,E)$，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。

**无向边**：若顶点 $v_i$ 到 $v_j$ 之间的边没有方向，则称这条边为无向边（Edge），用无序偶对$(v_i,v_j)$来表示。

**无向图**：如果图中任意两个顶点之间的边都是无向边，则称该图为无向图（Undirected graphs）。

**有向边**： 若从顶点$v_i$到的$v_j$边有方向，则称这条边为有向边，也称为弧（Arc）。

**有向图**：如果图中任意两个顶点之间的边都是有向边，则称该图为有向图（Directed graphs）。

**简单图**：在图中，若不存在顶点到自身的边，且同一条边不重复出现，则称这样的图为简单图。

**无向完全图**：在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。

**有向完全图**：在有向图中，如果任意两个顶点之间都存在互为相反的两条弧，则称该图为有向完全图。

**权**：有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权，权可以代表距离或耗费。

**子图**：设有两个图$G=(V,E)$，如果$\$V'∈V$且$E'∈E$，则称$G'$为$G$的子图。

**邻接点**：对于无向图$G=(V,E)$，如果边$(v,v')∈E$，则称顶点$v$和$v'$互为邻接点，即$v$和$v'$相邻接。

**度**：顶点$v$的度是和$v$相关联的边的数目。

**路径**：无向图$G=(V,E)$中从顶点$v$到顶点$v'$的路径是一个顶点序列$(v=v_{i0},v_{i1},...,v_{im}=v')$，其中$(v_{i,j-1},v_{i,j})∈E, 1≤j≤m$。如果$G$是有向图，则路径也是有向的，顶点序列应满足$<v_{i,j-1},v_{i,j}>∈E$, $1≤j≤m$。

### 10.2 表示

通常有两种表示方法，邻接表法和邻接矩阵表示。

 ![graph_rep.png](http://ww1.sinaimg.cn/large/b2f04ec3ly1gava17cy34j20lr0fgjti.jpg)

* 邻接表法：对于每个图中的点，将它的邻居放到一个链表中。
* 邻接矩阵法：对于 $n$ 个点，构造一个$n*n$的矩阵，如果有从点 $i$ 到点 $j$ 的边，就将矩阵的相应位置置为1。

<font color='red'>注意：</font>问题是用矩阵存储图是非常耗费空间的，大部分情况下为稀疏矩阵，因此，我们选择使用邻接表。

### 10.3 遍历

遍历图的最常用的有两种方式，就是BFS和DFS

* BFS：Breadth First Search，广度优先搜索
* DFS：Depth First Search，深度优先搜索

**构造**

我们先用字典和列表构建一个图，如下所示：

```python
graph = {
    'a': ['b', 'd', 'f'],
    'b': ['a', 'c', 'e'],
    'c': ['b', 'd'],
    'd': ['a', 'c'],
    'e': [],
    'f': ['a', 'g'],
    'g': []
}
```

<img src="http://ww1.sinaimg.cn/large/b2f04ec3ly1gav8pzv2uwj20ll0dwdg5.jpg" alt="图片1.png" style="zoom:67%;" />

#### 10.3.1 BFS

BFS类似于树的层次遍历，从第一个节点开始，先访问离A最近的点，接着访问次近的点，如何『由近及远』地访问节点呢，我们先访问a的邻居，然后邻居访问完之后再访问邻居的邻居不就行了？

**实现**：需要一个队列辅助，我们只需要把起点的邻居先入队，当邻居访问完了再去访问邻居的邻居就可以了，为了避免死循环(<font color='blue'>想想为什么？</font>)，对于已经访问过的节点，我们用一个set集合记录它就好了，代码如下：

```python
def BFS(graph, s):
    """广度优先遍历"""
    queue = []
    queue.append(s)
    seen = set()
    seen.add(s)
    while queue:
        vertex = queue.pop(0)
        nodes = graph[vertex]
        for node in nodes:
            if node not in seen:
                queue.append(node)
                seen.add(node)
        print(vertex, end=" -> ")
        
if __name__ == '__main__':
    BFS(graph, 'a')
```

<img src="http://ww1.sinaimg.cn/large/b2f04ec3ly1gavai34fxjj20lc0lcjsf.jpg" alt="bfs.png" style="zoom:80%;" />

#### 10.3.2 DFS

深度优先搜索就是每遇到一个节点，如果没有被访问到，就直接去访问它的邻居节点，不断加深，代码如下：

```python
def DFS(graph, s):
    """s深度优先遍历"""
    queue = []
    queue.append(s)
    seen = set()
    seen.add(s)
    while queue:
        vertex = queue.pop()
        nodes = graph[vertex]
        for node in nodes:
            if node not in seen:
                queue.append(node)
                seen.add(node)
        print(vertex, end=" -> ")
        
if __name__ == '__main__':
    BFS(graph, 'a')
```

还有一种实现方式为采用递归，这个不太好理解，如下：

```python
def recursiveDFS(graph, s, queue=[]):
    queue.append(s)
    for i in graph[s]:
        if i not in queue:
            recursiveDFS(graph, i, queue)
    return queue

if __name__ == '__main__':
     print(recursiveDFS(graph, 'a'))
```

好的，图的基本算法已经介绍完毕，下面介绍加权图

##### 狄克斯特拉算法

